{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Arm CMSIS Debugger extension The Arm CMSIS Debugger extension pack available in Visual Studio Code provides tools to debug projects built with the CMSIS-Toolbox . It contains a set of extensions that are required to create the debug environment and is shipped with pyOCD and a GDB frontend. The following extensions are included in this extension pack: CDT\u2122 GDB Debug Adapter Extension , an Eclipse CDT.cloud extension that supports debugging using GDB and any other debuggers that support the MI protocol. Memory Inspector , an Eclipse CDT.cloud extension that provides a powerful and configurable memory viewer that works with debug adapters. Peripheral Inspector , an Eclipse CDT.cloud extension that provides a CMSIS SVD viewer and works with debug adapters. Recommended extensions We recommend installing the following extensions to simplify the user experience: Arm Tools Environment Manager , an extension that allows to download, install, and manage software development tools using Microsoft\u00ae Vcpkg artifacts. Use this extension to for example install the GCC compiler for ARM CPUs which comes with a GDB variant for Arm CPUs. Arm CMSIS Solution , an extension that is a graphical user interface for csolution projects that use the CMSIS-Toolbox . Use this extension to build your csolution projects, to generate *.cbuild-run.yml debug configuration files, and to make use of contributed commands in your debug launch configurations. Supported debug probes The Arm CMSIS Debugger extension pack supports a wide range of debug probes: CMSIS-DAP v2.x . STMicroeletronics ST-LINK/V2/V3 . Segger J-Link . any debug probe that comes with a GDB Server. Multi-core debugging The Arm CMSIS Debugger is capable of multi-core debugging. For every core that you wish to connect to, you need to create a debug configuration . Using the same debug adapter, you can connect to the different target cores within one instance of VS Code. Contents Setup explains how to install the CMSIS Debugger extension and related debug components. Create launch configuration shows how to set up the debugger for single- and multi-core devices. Start debugging demonstrates how to enter the VS Code debugger. Debug views give you access to the code execution and device peripherals. Revision history Version Description 0.1.0 Initial release for the CMSIS Debugger extension version 0.1.0","title":"Home"},{"location":"index.html#arm-cmsis-debugger-extension","text":"The Arm CMSIS Debugger extension pack available in Visual Studio Code provides tools to debug projects built with the CMSIS-Toolbox . It contains a set of extensions that are required to create the debug environment and is shipped with pyOCD and a GDB frontend. The following extensions are included in this extension pack: CDT\u2122 GDB Debug Adapter Extension , an Eclipse CDT.cloud extension that supports debugging using GDB and any other debuggers that support the MI protocol. Memory Inspector , an Eclipse CDT.cloud extension that provides a powerful and configurable memory viewer that works with debug adapters. Peripheral Inspector , an Eclipse CDT.cloud extension that provides a CMSIS SVD viewer and works with debug adapters.","title":"Arm CMSIS Debugger extension"},{"location":"index.html#recommended-extensions","text":"We recommend installing the following extensions to simplify the user experience: Arm Tools Environment Manager , an extension that allows to download, install, and manage software development tools using Microsoft\u00ae Vcpkg artifacts. Use this extension to for example install the GCC compiler for ARM CPUs which comes with a GDB variant for Arm CPUs. Arm CMSIS Solution , an extension that is a graphical user interface for csolution projects that use the CMSIS-Toolbox . Use this extension to build your csolution projects, to generate *.cbuild-run.yml debug configuration files, and to make use of contributed commands in your debug launch configurations.","title":"Recommended extensions"},{"location":"index.html#supported-debug-probes","text":"The Arm CMSIS Debugger extension pack supports a wide range of debug probes: CMSIS-DAP v2.x . STMicroeletronics ST-LINK/V2/V3 . Segger J-Link . any debug probe that comes with a GDB Server.","title":"Supported debug probes"},{"location":"index.html#multi-core-debugging","text":"The Arm CMSIS Debugger is capable of multi-core debugging. For every core that you wish to connect to, you need to create a debug configuration . Using the same debug adapter, you can connect to the different target cores within one instance of VS Code.","title":"Multi-core debugging"},{"location":"index.html#contents","text":"Setup explains how to install the CMSIS Debugger extension and related debug components. Create launch configuration shows how to set up the debugger for single- and multi-core devices. Start debugging demonstrates how to enter the VS Code debugger. Debug views give you access to the code execution and device peripherals.","title":"Contents"},{"location":"index.html#revision-history","text":"Version Description 0.1.0 Initial release for the CMSIS Debugger extension version 0.1.0","title":"Revision history"},{"location":"configure.html","text":"Create a launch configuration In Visual Studio Code, the launch.json configuration file connects a debug session to the target hardware via a debug adapter. The following explains how to create the file for single- and multi-core devices using different debug adapters. The pseudo debugger types cmsis-debug-pyocd and cmsis-debug-jlink are available to set up the debug connection in the launch.json configuration file. However, these are not full debug adapters but generate debug configurations of type gdbtarget which comes with the CDT GDB Debug Adapter Extension that is part of the Arm CMSIS Debugger extension pack. Note Using pyOCD, you can connect to the target via CMSIS-DAP and ST-LINK debug probes. Prerequisites Make sure you have made the required changes to your CMSIS Solution-based project. If your project does not yet contain a launch.json file, create it as follows: Go to the Rund and Debug view . Click create a launch.json file link in the text. A quick-pick shows: Select CMSIS Debugger (pyOCD) or CMSIS Debugger (J-LINK) . This creates a new launch.json file under .vscode pre-filled with the selected default configuration. Debugging with pyOCD For debugging with pyOCD, the following is added to the launch.json file: { \"configurations\": [ { \"name\": \"CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load\", \"break main\" ], \"target\": { \"server\": \"pyocd\", \"port\": \"3333\" }, \"cmsis\": { \"cbuildRunFile\": \"${command:cmsis-csolution.getCbuildRunFile}\" } } ] } Single-core (pyOCD) For a single-core device, you need to add: the relative path to the HEX file to \"initCommands\" - \"load\" . an absolute \"definitionPath\" to the device's SVD file to be able to use the Periperals view . Example { \"configurations\": [ { \"name\": \"CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load ./out/Blinky/B-U585I-IOT02A/Debug/Blinky.hex\", \"break main\" ], \"target\": { \"server\": \"pyocd\", \"port\": \"3333\" }, \"cmsis\": { \"cbuildRunFile\": \"${command:cmsis-csolution.getCbuildRunFile}\" } \"definitionPath\": \"/Users/user/.cache/arm/packs/Keil/STM32U5xx_DFP/3.0.0/CMSIS/SVD/STM32U585.svd\" } ] } Multi-core (pyOCD) For a multi-core device, you need to: for the boot core: add the relative path to the HEX files for both cores to \"initCommands\" - \"load\" . for the secondary core: comment out the \"initCommands\" . for each core: add an absolute \"definitionPath\" to the device's SVD file to be able to use the Periperals view . add the relative path to the AXF (ELF) files for each core to \"program\" . Example { \"configurations\": [ { \"name\": \"CM4: CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.hex\", \"load out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.hex\", \"set $pc = Reset_Handler\", \"break main\" ], \"target\": { \"server\": \"pyocd\", \"port\": \"3333\" }, \"cmsis\": { \"cbuildRunFile\": \"FRDM-K32L3A6.cbuild-run.yml\" }, \"definitionPath\": \"/Users/user/.cache/arm/packs/NXP/K32L3A60_DFP/19.0.0/devices/K32L3A60/K32L3A60_cm4.xml\" }, { \"name\": \"CM0+: CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"attach\", \"cwd\": \"${workspaceFolder}\", \"program\": \"out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf\", \"gdb\": \"arm-none-eabi-gdb\", // \"initCommands\": [ // \"load\", // \"break main\" // ], \"target\": { \"server\": \"pyocd\", \"port\": \"3334\" }, \"definitionPath\": \"/Users/user/.cache/arm/packs/NXP/K32L3A60_DFP/19.0.0/devices/K32L3A60/K32L3A60_cm0plus.xml\" } ] } Note In this example, the \"set $pc = Reset_Handler\", is required to set the program counter to the correct value. Debugging with J-Link For debugging with Segger J-Link (using the J-Link GDB Server ), the following is added to the launch.json file: { \"configurations\": [ { \"name\": \"CMSIS Debugger: J-LINK\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load\", \"break main\" ], \"target\": { \"server\": \"JLinkGDBServer\", \"serverParameters\": [ \"-device\", \"${command:cmsis-csolution.getDeviceName}\", \"-endian\", \"little\", \"-if\", \"SWD\", \"-speed\", \"auto\", \"-noir\", \"-vd\", \"-nogui\", \"-localhostonly\" ], \"port\": \"3333\" } } ] } Single-core (J-Link) For a single-core device, the configuration template contains all the information that is required to start debugging. Attention Check if the above statement is true! Multi-core (J-Link) For a multi-core device, you need to: change the \"-device\" entry to add processor names. create a JLinkDevices.xml file containing entries for all cores (refer to the J-Link Device Support Kit documentation on how to do that). add the XML file to the \"serverParameters\" so that the Segger GDB server can pick them up. Example { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"CMSIS Debugger: J-LINK\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load\", \"break main\" ], \"target\": { \"server\": \"JLinkGDBServer\", \"serverParameters\": [ \"-device\", \"${command:cmsis-csolution.getDeviceName}_${command:cmsis-csolution.getProcessorName}\", \"-JLinkDevicesXmlPath\", \".alif/JLinkDevices.xml\", \"-endian\", \"little\", \"-if\", \"SWD\", \"-speed\", \"auto\", \"-noir\", \"-vd\", \"-nogui\", \"-localhostonly\" ], \"port\": \"3333\" } } ] } For this example, the content of the JLinkDevices.xml file is as follows: <DataBase> <Device> <ChipInfo Vendor=\"AlifSemiconductor\" Name=\"AE722F80F55D5_HP\" Aliases=\"AE722F80F55D5LS_M55_HP; AE722F80F55D5AS_M55_HP\" /> </Device> <Device> <ChipInfo Vendor=\"AlifSemiconductor\" Name=\"AE722F80F55D5_HE\" Aliases=\"AE722F80F55D5LS_M55_HE; AE722F80F55D5AS_M55_HE\" /> </Device> </DataBase>","title":"Create launch configuration"},{"location":"configure.html#create-a-launch-configuration","text":"In Visual Studio Code, the launch.json configuration file connects a debug session to the target hardware via a debug adapter. The following explains how to create the file for single- and multi-core devices using different debug adapters. The pseudo debugger types cmsis-debug-pyocd and cmsis-debug-jlink are available to set up the debug connection in the launch.json configuration file. However, these are not full debug adapters but generate debug configurations of type gdbtarget which comes with the CDT GDB Debug Adapter Extension that is part of the Arm CMSIS Debugger extension pack. Note Using pyOCD, you can connect to the target via CMSIS-DAP and ST-LINK debug probes.","title":"Create a launch configuration"},{"location":"configure.html#prerequisites","text":"Make sure you have made the required changes to your CMSIS Solution-based project. If your project does not yet contain a launch.json file, create it as follows: Go to the Rund and Debug view . Click create a launch.json file link in the text. A quick-pick shows: Select CMSIS Debugger (pyOCD) or CMSIS Debugger (J-LINK) . This creates a new launch.json file under .vscode pre-filled with the selected default configuration.","title":"Prerequisites"},{"location":"configure.html#debugging-with-pyocd","text":"For debugging with pyOCD, the following is added to the launch.json file: { \"configurations\": [ { \"name\": \"CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load\", \"break main\" ], \"target\": { \"server\": \"pyocd\", \"port\": \"3333\" }, \"cmsis\": { \"cbuildRunFile\": \"${command:cmsis-csolution.getCbuildRunFile}\" } } ] }","title":"Debugging with pyOCD"},{"location":"configure.html#single-core-pyocd","text":"For a single-core device, you need to add: the relative path to the HEX file to \"initCommands\" - \"load\" . an absolute \"definitionPath\" to the device's SVD file to be able to use the Periperals view . Example { \"configurations\": [ { \"name\": \"CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load ./out/Blinky/B-U585I-IOT02A/Debug/Blinky.hex\", \"break main\" ], \"target\": { \"server\": \"pyocd\", \"port\": \"3333\" }, \"cmsis\": { \"cbuildRunFile\": \"${command:cmsis-csolution.getCbuildRunFile}\" } \"definitionPath\": \"/Users/user/.cache/arm/packs/Keil/STM32U5xx_DFP/3.0.0/CMSIS/SVD/STM32U585.svd\" } ] }","title":"Single-core (pyOCD)"},{"location":"configure.html#multi-core-pyocd","text":"For a multi-core device, you need to: for the boot core: add the relative path to the HEX files for both cores to \"initCommands\" - \"load\" . for the secondary core: comment out the \"initCommands\" . for each core: add an absolute \"definitionPath\" to the device's SVD file to be able to use the Periperals view . add the relative path to the AXF (ELF) files for each core to \"program\" . Example { \"configurations\": [ { \"name\": \"CM4: CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.axf\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load out/HelloWorld_cm4/FRDM-K32L3A6/Debug/HelloWorld_cm4.hex\", \"load out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.hex\", \"set $pc = Reset_Handler\", \"break main\" ], \"target\": { \"server\": \"pyocd\", \"port\": \"3333\" }, \"cmsis\": { \"cbuildRunFile\": \"FRDM-K32L3A6.cbuild-run.yml\" }, \"definitionPath\": \"/Users/user/.cache/arm/packs/NXP/K32L3A60_DFP/19.0.0/devices/K32L3A60/K32L3A60_cm4.xml\" }, { \"name\": \"CM0+: CMSIS Debugger: pyOCD\", \"type\": \"gdbtarget\", \"request\": \"attach\", \"cwd\": \"${workspaceFolder}\", \"program\": \"out/HelloWorld_cm0plus/FRDM-K32L3A6/Debug/HelloWorld_cm0plus.axf\", \"gdb\": \"arm-none-eabi-gdb\", // \"initCommands\": [ // \"load\", // \"break main\" // ], \"target\": { \"server\": \"pyocd\", \"port\": \"3334\" }, \"definitionPath\": \"/Users/user/.cache/arm/packs/NXP/K32L3A60_DFP/19.0.0/devices/K32L3A60/K32L3A60_cm0plus.xml\" } ] } Note In this example, the \"set $pc = Reset_Handler\", is required to set the program counter to the correct value.","title":"Multi-core (pyOCD)"},{"location":"configure.html#debugging-with-j-link","text":"For debugging with Segger J-Link (using the J-Link GDB Server ), the following is added to the launch.json file: { \"configurations\": [ { \"name\": \"CMSIS Debugger: J-LINK\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load\", \"break main\" ], \"target\": { \"server\": \"JLinkGDBServer\", \"serverParameters\": [ \"-device\", \"${command:cmsis-csolution.getDeviceName}\", \"-endian\", \"little\", \"-if\", \"SWD\", \"-speed\", \"auto\", \"-noir\", \"-vd\", \"-nogui\", \"-localhostonly\" ], \"port\": \"3333\" } } ] }","title":"Debugging with J-Link"},{"location":"configure.html#single-core-j-link","text":"For a single-core device, the configuration template contains all the information that is required to start debugging. Attention Check if the above statement is true!","title":"Single-core (J-Link)"},{"location":"configure.html#multi-core-j-link","text":"For a multi-core device, you need to: change the \"-device\" entry to add processor names. create a JLinkDevices.xml file containing entries for all cores (refer to the J-Link Device Support Kit documentation on how to do that). add the XML file to the \"serverParameters\" so that the Segger GDB server can pick them up. Example { \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"CMSIS Debugger: J-LINK\", \"type\": \"gdbtarget\", \"request\": \"launch\", \"cwd\": \"${workspaceFolder}\", \"program\": \"${command:cmsis-csolution.getBinaryFile}\", \"gdb\": \"arm-none-eabi-gdb\", \"initCommands\": [ \"load\", \"break main\" ], \"target\": { \"server\": \"JLinkGDBServer\", \"serverParameters\": [ \"-device\", \"${command:cmsis-csolution.getDeviceName}_${command:cmsis-csolution.getProcessorName}\", \"-JLinkDevicesXmlPath\", \".alif/JLinkDevices.xml\", \"-endian\", \"little\", \"-if\", \"SWD\", \"-speed\", \"auto\", \"-noir\", \"-vd\", \"-nogui\", \"-localhostonly\" ], \"port\": \"3333\" } } ] } For this example, the content of the JLinkDevices.xml file is as follows: <DataBase> <Device> <ChipInfo Vendor=\"AlifSemiconductor\" Name=\"AE722F80F55D5_HP\" Aliases=\"AE722F80F55D5LS_M55_HP; AE722F80F55D5AS_M55_HP\" /> </Device> <Device> <ChipInfo Vendor=\"AlifSemiconductor\" Name=\"AE722F80F55D5_HE\" Aliases=\"AE722F80F55D5LS_M55_HE; AE722F80F55D5AS_M55_HE\" /> </Device> </DataBase>","title":"Multi-core (J-Link)"},{"location":"debug.html","text":"Start debugging There are two ways to start a debug session: In the CMSIS view , click on the Debug icon . Depending on the number of configurations in your launch.json file, you will be asked to select a configuration for the debug session. In the Run and debug view , click the Play icon next to the selected debug connection . The debug starts with the selected configuration. The debugger loads the application program and executes the startup code. When program execution stops (by default at main ), the source code opens at the next executable statement which is marked with a yellow arrow in the editor: Most editor features are available in debug mode. For example, developers can use the Find command and can correct program errors. Flash and run If you do not wish to enter a debug session, you can issue a flash download only, followed by a reset of the device. In the CMSIS view , click on the Run icon .","title":"Start debugging"},{"location":"debug.html#start-debugging","text":"There are two ways to start a debug session: In the CMSIS view , click on the Debug icon . Depending on the number of configurations in your launch.json file, you will be asked to select a configuration for the debug session. In the Run and debug view , click the Play icon next to the selected debug connection . The debug starts with the selected configuration. The debugger loads the application program and executes the startup code. When program execution stops (by default at main ), the source code opens at the next executable statement which is marked with a yellow arrow in the editor: Most editor features are available in debug mode. For example, developers can use the Find command and can correct program errors.","title":"Start debugging"},{"location":"debug.html#flash-and-run","text":"If you do not wish to enter a debug session, you can issue a flash download only, followed by a reset of the device. In the CMSIS view , click on the Run icon .","title":"Flash and run"},{"location":"debug_views.html","text":"Run and Debug view The Run and debug view differs from the other views in the following aspects: Debug toolbar is available. VARIABLE section is available. WATCH section is available. CALL STACK section is available. BREAKPOINTS section is available. Peripheral Inspector is available (requires configuration). Memory Inspector can be opened. Disassembly View can be opened. Debug Console can be used to enter GDB commands. Note The following is using information from Debug code with Visual Studio Code , Eclipse CDT Cloud - Memory Inspector , Eclipse CDT Cloud - Peripherals Inspector . Debug toolbar Once a debug session starts, the Debug toolbar appears at the top of the window. The toolbar contains actions to control the flow of the debug session, such as stepping through code, pausing execution, and stopping the debug session. The following table describes the actions available in the debug toolbar: Action Description Continue/Pause (F5) Continue : Resume normal program/script execution (up to the next breakpoint). Pause : Inspect code executing at the current line and debug line-by-line. Step Over (F10) Execute the next method as a single command without inspecting or following its component steps. Step Into (F11) Enter the next method to follow its execution line-by-line. Step Out (Shift + F11) When inside a method or subroutine, return to the earlier execution context by completing remaining lines of the current method as though it were a single command. Restart (Shift + Ctrl/Cmd + F5) Terminate the current program execution and start debugging again using the current run configuration. Stop (Shift + F5) Terminate the current program execution. If your debugging sessions involve multiple targets (for example, a multi-core device), the debug toolbar shows the list of sessions and lets you switch between them. VARIABLES section During a debugging session, you can inspect variables, expressions, and registers in the VARIABLES section of the Run and Debug view or by hovering over their source in the editor. Variable values and expression evaluation are relative to the selected stack frame in the CALL STACK section . In case of multi-core, registers are relative to the core that you are debugging. To change the value of a variable during the debugging session, right-click on the variable in the VARIABLES section and select Set Value . You can use the Copy Value action to copy the variable's value, or the Copy as Expression action to copy an iexpression to access the variable. You can then use this expression in the WATCH section . To filter variables by their name or value, use the Alt/Opt + Ctrl/Cmd + F keyboard shortcut while the focus is on the VARIABLES section , and type a search term. WATCH section Variables and expressions can also be evaluated and watched in the Run and Debug view's WATCH section. CALL STACK section The CALL STACK sections shows objects that are currently on stack. Threads are shown for applications that use an RTOS. Each object is associated to its location or value, and type. The window content is updated automatically whenever program execution stops. The context menu allows to: copy the call stack. open Disassembly View . BREAKPOINTS section A breakpoint pauses the execution of your code at a specific point, so you can inspect the state of your application at that point. VS Code supports several types of breakpoints. Setting breakpoints To set or unset a breakpoint, click on the editor margin or use F9 on the current line. Breakpoints in the editor margin are normally shown as red filled circles. Disabled breakpoints have a filled gray circle. When a debugging session starts, breakpoints that can't be registered with the debugger change to a gray hollow circle. The same might happen if the source is edited while a debug session without live-edit support is running. For more control of your breakpoints, use the Run and Debug view's BREAKPOINTS section . This section lists all breakpoints in your code and provides extra actions to manage them. Breakpoint types Conditional breakpoints A powerful VS Code debugging feature is the ability to set conditions based on expressions, hit counts, or a combination of both. Expression condition: The breakpoint is hit whenever the expression evaluates to true. Hit count: The hit count controls how many times a breakpoint needs to be hit before it interrupts execution. Wait for breakpoint: The breakpoint is activated when another breakpoint is hit ( triggered breakpoint ). To add a conditional breakpoint: Create a conditional breakpoint Right-click in the editor margin and select Add Conditional Breakpoint. Use the Add Conditional Breakpoint command in the Command Palette (\u21e7\u2318P). Choose the type of condition you want to set (expression, hit count, or wait for breakpoint). To add a condition to an existing breakpoint: Edit an existing breakpoint Right-click on the breakpoint in the editor margin and select Edit Breakpoint. Select the pencil icon next for an existing breakpoint in the BREAKPOINTS section of the Run and Debug view . Edit the condition (expression, hit count, or wait for breakpoint). Triggered breakpoints A triggered breakpoint is type of conditional breakpoint that is enabled once another breakpoint is hit. They can be useful when diagnosing failure cases in code that happen only after a certain precondition. Triggered breakpoints can be set by right-clicking on the glyph margin, selecting Add Triggered Breakpoint , and then choosing which other breakpoint enables the breakpoint. Inline breakpoints Inline breakpoints are only hit when the execution reaches the column associated with the inline breakpoint. This is useful when debugging minified code, which contains multiple statements in a single line. An inline breakpoint can be set using Shift + F9 or through the context menu during a debug session. Inline breakpoint are shown inline in the editor. Inline breakpoints can also have conditions. Editing multiple breakpoints on a line is possible through the context menu in the editor's left margin. Function breakpoints Instead of placing breakpoints directly in source code, a debugger can support creating breakpoints by specifying a function name. This is useful in situations where source is not available but a function name is known. To create a function breakpoint, select the + button in the BREAKPOINTS section header and enter the function name. Function breakpoints are shown with a red triangle in the BREAKPOINTS section . Data breakpoints If a debugger supports data breakpoints, they can be set from the context menu in the VARIABLES section . The Break on Value Change/Read/Access commands add a data breakpoint that is hit when the value of the underlying variable changes/is read/is accessed. Data breakpoints are shown with a red hexagon in the BREAKPOINTS section . Logpoints A logpoint is a variant of a breakpoint that does not interrupt into the debugger, but instead logs a message to the debug console. Logpoints can help you save time by not having to add or remove logging statements in your code. A logpoint is represented by a diamond-shaped icon. Log messages are plain text but can also include expressions to be evaluated within curly braces ('{}'). To add a logpoint, right-click in the editor left margin and select Add Logpoint, or use the Debug: Add Logpoint... command in the Command Palette ( Ctrl/Cmd + Shift + p ). Just like regular breakpoints, logpoints can be enabled or disabled and can also be controlled by a condition and/or hit count. PERIPHERAL Inspector The Eclipse CDT Cloud Periperhal Inspector is a standalone SVD Viewer extension. For more information, refer to the Peripheral Inspector GitHub repository . Memory Inspector The Eclipse CDT Cloud Memory Inspector provides a powerful and configurable memory viewer that works with debug adapters. It features: Configurable Memory Display: Shows memory data with various display options. Address Navigation: Easily jump to and scroll through memory addresses. Variable Highlights: Colors memory ranges for variables. Multiple Memory Formats: Shows memory data on hover in multiple formats. Edit Memory: Allows in-place memory editing, if the debug adapter supports the WriteMemoryRequest. Memory Management: Enables saving and restoring memory data for specific address ranges (Intel Hex format). Customized Views: Create and customize as many memory views as you need. Lock Views: Keep views static, unaffected by updates from the debug session. Periodic Refresh: Automatically refresh the memory data. Multiple Debug Sessions: Switch between multiple debug sessions using a dropdown in the memory view. For more information, refer to the Memory Inspector GitHub repository . Disassembly View The Disassembly View shows the program execution in assembly code intermixed with the source code. To open the Disassembly View : press Ctrl/Cmd + Shift + p and select \"Open Disassembly View\" or Right-click an item in the CALL STACK section and select \"Open Disassembly View\" Debug Console The Debug Console enables viewing and interacting with the output of your code running in the debugger. Expressions can be evaluated with the Debug Console REPL (Read-Eval-Print Loop) feature. With the CMSIS Debug extension, you can use the Debug Console REPL to enter GDB commands while debugging. Before entering a GDB command, you have to explicitly enter a \"greater-than\"-character > so that the following strings can be evaluated as a GDB command. Debug Console input uses the mode of the active editor, which means that it supports syntax coloring, indentation, auto closing of quotes, and other language features. Example The following example shows how to check the currently set breakpoints with the > info break command. Afterwards, the application is run with the > continue command.","title":"Debug views"},{"location":"debug_views.html#run-and-debug-view","text":"The Run and debug view differs from the other views in the following aspects: Debug toolbar is available. VARIABLE section is available. WATCH section is available. CALL STACK section is available. BREAKPOINTS section is available. Peripheral Inspector is available (requires configuration). Memory Inspector can be opened. Disassembly View can be opened. Debug Console can be used to enter GDB commands. Note The following is using information from Debug code with Visual Studio Code , Eclipse CDT Cloud - Memory Inspector , Eclipse CDT Cloud - Peripherals Inspector .","title":"Run and Debug view"},{"location":"debug_views.html#debug-toolbar","text":"Once a debug session starts, the Debug toolbar appears at the top of the window. The toolbar contains actions to control the flow of the debug session, such as stepping through code, pausing execution, and stopping the debug session. The following table describes the actions available in the debug toolbar: Action Description Continue/Pause (F5) Continue : Resume normal program/script execution (up to the next breakpoint). Pause : Inspect code executing at the current line and debug line-by-line. Step Over (F10) Execute the next method as a single command without inspecting or following its component steps. Step Into (F11) Enter the next method to follow its execution line-by-line. Step Out (Shift + F11) When inside a method or subroutine, return to the earlier execution context by completing remaining lines of the current method as though it were a single command. Restart (Shift + Ctrl/Cmd + F5) Terminate the current program execution and start debugging again using the current run configuration. Stop (Shift + F5) Terminate the current program execution. If your debugging sessions involve multiple targets (for example, a multi-core device), the debug toolbar shows the list of sessions and lets you switch between them.","title":"Debug toolbar"},{"location":"debug_views.html#variables-section","text":"During a debugging session, you can inspect variables, expressions, and registers in the VARIABLES section of the Run and Debug view or by hovering over their source in the editor. Variable values and expression evaluation are relative to the selected stack frame in the CALL STACK section . In case of multi-core, registers are relative to the core that you are debugging. To change the value of a variable during the debugging session, right-click on the variable in the VARIABLES section and select Set Value . You can use the Copy Value action to copy the variable's value, or the Copy as Expression action to copy an iexpression to access the variable. You can then use this expression in the WATCH section . To filter variables by their name or value, use the Alt/Opt + Ctrl/Cmd + F keyboard shortcut while the focus is on the VARIABLES section , and type a search term.","title":"VARIABLES section"},{"location":"debug_views.html#watch-section","text":"Variables and expressions can also be evaluated and watched in the Run and Debug view's WATCH section.","title":"WATCH section"},{"location":"debug_views.html#call-stack-section","text":"The CALL STACK sections shows objects that are currently on stack. Threads are shown for applications that use an RTOS. Each object is associated to its location or value, and type. The window content is updated automatically whenever program execution stops. The context menu allows to: copy the call stack. open Disassembly View .","title":"CALL STACK section"},{"location":"debug_views.html#breakpoints-section","text":"A breakpoint pauses the execution of your code at a specific point, so you can inspect the state of your application at that point. VS Code supports several types of breakpoints.","title":"BREAKPOINTS section"},{"location":"debug_views.html#setting-breakpoints","text":"To set or unset a breakpoint, click on the editor margin or use F9 on the current line. Breakpoints in the editor margin are normally shown as red filled circles. Disabled breakpoints have a filled gray circle. When a debugging session starts, breakpoints that can't be registered with the debugger change to a gray hollow circle. The same might happen if the source is edited while a debug session without live-edit support is running. For more control of your breakpoints, use the Run and Debug view's BREAKPOINTS section . This section lists all breakpoints in your code and provides extra actions to manage them.","title":"Setting breakpoints"},{"location":"debug_views.html#breakpoint-types","text":"","title":"Breakpoint types"},{"location":"debug_views.html#conditional-breakpoints","text":"A powerful VS Code debugging feature is the ability to set conditions based on expressions, hit counts, or a combination of both. Expression condition: The breakpoint is hit whenever the expression evaluates to true. Hit count: The hit count controls how many times a breakpoint needs to be hit before it interrupts execution. Wait for breakpoint: The breakpoint is activated when another breakpoint is hit ( triggered breakpoint ). To add a conditional breakpoint: Create a conditional breakpoint Right-click in the editor margin and select Add Conditional Breakpoint. Use the Add Conditional Breakpoint command in the Command Palette (\u21e7\u2318P). Choose the type of condition you want to set (expression, hit count, or wait for breakpoint). To add a condition to an existing breakpoint: Edit an existing breakpoint Right-click on the breakpoint in the editor margin and select Edit Breakpoint. Select the pencil icon next for an existing breakpoint in the BREAKPOINTS section of the Run and Debug view . Edit the condition (expression, hit count, or wait for breakpoint).","title":"Conditional breakpoints"},{"location":"debug_views.html#triggered-breakpoints","text":"A triggered breakpoint is type of conditional breakpoint that is enabled once another breakpoint is hit. They can be useful when diagnosing failure cases in code that happen only after a certain precondition. Triggered breakpoints can be set by right-clicking on the glyph margin, selecting Add Triggered Breakpoint , and then choosing which other breakpoint enables the breakpoint.","title":"Triggered breakpoints"},{"location":"debug_views.html#inline-breakpoints","text":"Inline breakpoints are only hit when the execution reaches the column associated with the inline breakpoint. This is useful when debugging minified code, which contains multiple statements in a single line. An inline breakpoint can be set using Shift + F9 or through the context menu during a debug session. Inline breakpoint are shown inline in the editor. Inline breakpoints can also have conditions. Editing multiple breakpoints on a line is possible through the context menu in the editor's left margin.","title":"Inline breakpoints"},{"location":"debug_views.html#function-breakpoints","text":"Instead of placing breakpoints directly in source code, a debugger can support creating breakpoints by specifying a function name. This is useful in situations where source is not available but a function name is known. To create a function breakpoint, select the + button in the BREAKPOINTS section header and enter the function name. Function breakpoints are shown with a red triangle in the BREAKPOINTS section .","title":"Function breakpoints"},{"location":"debug_views.html#data-breakpoints","text":"If a debugger supports data breakpoints, they can be set from the context menu in the VARIABLES section . The Break on Value Change/Read/Access commands add a data breakpoint that is hit when the value of the underlying variable changes/is read/is accessed. Data breakpoints are shown with a red hexagon in the BREAKPOINTS section .","title":"Data breakpoints"},{"location":"debug_views.html#logpoints","text":"A logpoint is a variant of a breakpoint that does not interrupt into the debugger, but instead logs a message to the debug console. Logpoints can help you save time by not having to add or remove logging statements in your code. A logpoint is represented by a diamond-shaped icon. Log messages are plain text but can also include expressions to be evaluated within curly braces ('{}'). To add a logpoint, right-click in the editor left margin and select Add Logpoint, or use the Debug: Add Logpoint... command in the Command Palette ( Ctrl/Cmd + Shift + p ). Just like regular breakpoints, logpoints can be enabled or disabled and can also be controlled by a condition and/or hit count.","title":"Logpoints"},{"location":"debug_views.html#peripheral-inspector","text":"The Eclipse CDT Cloud Periperhal Inspector is a standalone SVD Viewer extension. For more information, refer to the Peripheral Inspector GitHub repository .","title":"PERIPHERAL Inspector"},{"location":"debug_views.html#memory-inspector","text":"The Eclipse CDT Cloud Memory Inspector provides a powerful and configurable memory viewer that works with debug adapters. It features: Configurable Memory Display: Shows memory data with various display options. Address Navigation: Easily jump to and scroll through memory addresses. Variable Highlights: Colors memory ranges for variables. Multiple Memory Formats: Shows memory data on hover in multiple formats. Edit Memory: Allows in-place memory editing, if the debug adapter supports the WriteMemoryRequest. Memory Management: Enables saving and restoring memory data for specific address ranges (Intel Hex format). Customized Views: Create and customize as many memory views as you need. Lock Views: Keep views static, unaffected by updates from the debug session. Periodic Refresh: Automatically refresh the memory data. Multiple Debug Sessions: Switch between multiple debug sessions using a dropdown in the memory view. For more information, refer to the Memory Inspector GitHub repository .","title":"Memory Inspector"},{"location":"debug_views.html#disassembly-view","text":"The Disassembly View shows the program execution in assembly code intermixed with the source code. To open the Disassembly View : press Ctrl/Cmd + Shift + p and select \"Open Disassembly View\" or Right-click an item in the CALL STACK section and select \"Open Disassembly View\"","title":"Disassembly View"},{"location":"debug_views.html#debug-console","text":"The Debug Console enables viewing and interacting with the output of your code running in the debugger. Expressions can be evaluated with the Debug Console REPL (Read-Eval-Print Loop) feature. With the CMSIS Debug extension, you can use the Debug Console REPL to enter GDB commands while debugging. Before entering a GDB command, you have to explicitly enter a \"greater-than\"-character > so that the following strings can be evaluated as a GDB command. Debug Console input uses the mode of the active editor, which means that it supports syntax coloring, indentation, auto closing of quotes, and other language features. Example The following example shows how to check the currently set breakpoints with the > info break command. Afterwards, the application is run with the > continue command.","title":"Debug Console"},{"location":"multi-core.html","text":"","title":"Multi core"},{"location":"setup.html","text":"Setup This chapter describes how to install the Arm CMSIS Debugger extension pack and how to configure the debug connection for single- and multi-core devices. Installation The Arm CMSIS Debugger extension pack includes extensions that you can use to debug CMSIS solution-based projects. In Visual Studio Code, open the Extensions view and type Arm CMSIS Debugger in the search bar. Click Install to start the installation. Debug Setup The debug setup requires a GDB installation supporting the GDB remote protocol and that can connect to a GDB server like pyOCD. We recommend installing the Arm GNU Toolchain using the Arm Tools Environment Manager extension. It comes with arm-none-eabi-gdb which is used in the Arm CMSIS Debugger default debug configurations. pyOCD Debug Setup This extension includes a pyOCD distribution which is used by default. The cmsis-debug-pyocd debugger type is used to add a debug configuration in the launch.json file for debugging with GDB and pyOCD. This configuration uses the gdbtarget debugger type registered by the CDT GDB Debug Adapter Extension. If you wish to use a different pyOCD installation, enter the full path to the executable (including the file name) in the target > server setting in the launch.json configuration file. SEGGER\u00ae J-LINK\u00ae Debug Setup Install the latest J-LINK Software and Documentation Pack from SEGGER . Ensure all required drivers and host platform specific settings are done. The extension expects the installation folder to be on your system PATH environment variable. Alternatively, update your debug configuration's target > server setting to contain the full path to the J-LINK GDB server executable (including the file name). The cmsis-debug-jlink debugger type is used to add a debug configuration in the launch.json file for debug with GDB and the SEGGER J-LINK GDB server. This configuration uses the gdbtarget debugger type registered by the CDT GDB Debug Adapter Extension. Project setup To be able to use the GNU Debugger under the hood, you need to make sure that the project build process creates the right binary files in the correct formats. Thus, you need to amend your project's *.csolution.yml and *.cproject.yml files. Make sure that the ELF file is written using the DWARF Verion 5 format. For example, when generated with the Arm Compiler for Embedded , add the following to your *.csolution.yml file (before the projects: section for example): misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler Note For other toolchians, please consult the reference manual on how to generate DWARF Version 5 formatted ELF files. In addition to generating an ELF file, you also need to create a HEX file that will be used to flash the firmware image. Add the following to any of your *.cproject.yml files (at the end of the file): output: type: - elf - hex","title":"Setup"},{"location":"setup.html#setup","text":"This chapter describes how to install the Arm CMSIS Debugger extension pack and how to configure the debug connection for single- and multi-core devices.","title":"Setup"},{"location":"setup.html#installation","text":"The Arm CMSIS Debugger extension pack includes extensions that you can use to debug CMSIS solution-based projects. In Visual Studio Code, open the Extensions view and type Arm CMSIS Debugger in the search bar. Click Install to start the installation.","title":"Installation"},{"location":"setup.html#debug-setup","text":"The debug setup requires a GDB installation supporting the GDB remote protocol and that can connect to a GDB server like pyOCD. We recommend installing the Arm GNU Toolchain using the Arm Tools Environment Manager extension. It comes with arm-none-eabi-gdb which is used in the Arm CMSIS Debugger default debug configurations.","title":"Debug Setup"},{"location":"setup.html#pyocd-debug-setup","text":"This extension includes a pyOCD distribution which is used by default. The cmsis-debug-pyocd debugger type is used to add a debug configuration in the launch.json file for debugging with GDB and pyOCD. This configuration uses the gdbtarget debugger type registered by the CDT GDB Debug Adapter Extension. If you wish to use a different pyOCD installation, enter the full path to the executable (including the file name) in the target > server setting in the launch.json configuration file.","title":"pyOCD Debug Setup"},{"location":"setup.html#segger-j-link-debug-setup","text":"Install the latest J-LINK Software and Documentation Pack from SEGGER . Ensure all required drivers and host platform specific settings are done. The extension expects the installation folder to be on your system PATH environment variable. Alternatively, update your debug configuration's target > server setting to contain the full path to the J-LINK GDB server executable (including the file name). The cmsis-debug-jlink debugger type is used to add a debug configuration in the launch.json file for debug with GDB and the SEGGER J-LINK GDB server. This configuration uses the gdbtarget debugger type registered by the CDT GDB Debug Adapter Extension.","title":"SEGGER\u00ae J-LINK\u00ae Debug Setup"},{"location":"setup.html#project-setup","text":"To be able to use the GNU Debugger under the hood, you need to make sure that the project build process creates the right binary files in the correct formats. Thus, you need to amend your project's *.csolution.yml and *.cproject.yml files. Make sure that the ELF file is written using the DWARF Verion 5 format. For example, when generated with the Arm Compiler for Embedded , add the following to your *.csolution.yml file (before the projects: section for example): misc: - for-compiler: AC6 C-CPP: - -gdwarf-5 ASM: - -gdwarf-5 Link: - --entry=Reset_Handler Note For other toolchians, please consult the reference manual on how to generate DWARF Version 5 formatted ELF files. In addition to generating an ELF file, you also need to create a HEX file that will be used to flash the firmware image. Add the following to any of your *.cproject.yml files (at the end of the file): output: type: - elf - hex","title":"Project setup"},{"location":"single-core.html","text":"","title":"Single core"},{"location":"tpip-header.html","text":"TPIP Report for vscode-cmsis-debugger","title":"TPIP Report for vscode-cmsis-debugger"},{"location":"tpip-header.html#tpip-report-for-vscode-cmsis-debugger","text":"","title":"TPIP Report for vscode-cmsis-debugger"}]}